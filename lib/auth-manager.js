const AuthAPI = require('./auth-api');
const DeviceFingerprint = require('./device-fingerprint');
const { log, error } = require('./logger');

class AuthManager {
    constructor(storageManager) {
        this.storageManager = storageManager;
        this.authAPI = new AuthAPI();
        this.checkIntervalId = null;
        this.isCheckingLicense = false;
    }

    /**
     * ƒêƒÉng k√Ω t√†i kho·∫£n m·ªõi
     */
    async register(userData) {
        try {
            log('üîê Starting registration process for:', userData.username);

            // G·ªçi API ƒëƒÉng k√Ω
            const result = await this.authAPI.register(userData);
            
            if (result.success) {
                // L∆∞u auth data v√†o database
                await this.storageManager.saveAuthData(result.data);
                
                // L·∫•y th√¥ng tin license t·ª´ API
                await this.updateLicenseFromAPI(result.data.token);
                
                // B·∫Øt ƒë·∫ßu schedule check license
                this.startLicenseCheck();
                
                log('‚úÖ Registration completed successfully');
                return {
                    success: true,
                    user: result.data.user,
                    message: result.message
                };
            } else {
                return result;
            }
        } catch (err) {
            error('‚ùå Registration error:', err);
            return {
                success: false,
                error: 'Registration failed: ' + err.message
            };
        }
    }

    /**
     * ƒêƒÉng nh·∫≠p
     */
    async login(credentials) {
        try {
            const deviceData = await DeviceFingerprint.getDeviceInfo();
            credentials.deviceId = deviceData.deviceId;
            // log("deviceData",deviceData)
            log('üîê Starting login process for:', credentials.username);

            // G·ªçi API ƒëƒÉng nh·∫≠p
            const result = await this.authAPI.login(credentials);
            
            if (result.success) {
                // L∆∞u auth data v√†o database
                await this.storageManager.saveAuthData(result.data);
                
                // L·∫•y th√¥ng tin license t·ª´ API
                await this.updateLicenseFromAPI(result.data.token);
                
                // B·∫Øt ƒë·∫ßu schedule check license
                this.startLicenseCheck();
                
                log('‚úÖ Login completed successfully');
                return {
                    success: true,
                    user: result.data.user,
                    message: result.message
                };
            } else {
                return result;
            }
        } catch (err) {
            error('‚ùå Login error:', err);
            return {
                success: false,
                error: 'Login failed: ' + err.message
            };
        }
    }

    /**
     * ƒêƒÉng xu·∫•t
     */
    async logout() {
        try {
            log('üëã Starting logout process');

            // L·∫•y token hi·ªán t·∫°i
            const token = await this.storageManager.getCurrentToken();
            
            // G·ªçi API logout n·∫øu c√≥ token
            if (token) {
                await this.authAPI.logout(token);
            }
            
            // X√≥a auth data local
            await this.storageManager.clearAuthData();
            
            // X√≥a license data
            await this.storageManager.clearLicenseData();
            
            // Stop license check
            this.stopLicenseCheck();
            
            log('‚úÖ Logout completed successfully');
            return { success: true };
        } catch (err) {
            error('‚ùå Logout error:', err);
            // V·∫´n clear local data d√π API call fail
            await this.storageManager.clearAuthData();
            await this.storageManager.clearLicenseData();
            this.stopLicenseCheck();
            
            return { success: true };
        }
    }

    /**
     * Ki·ªÉm tra tr·∫°ng th√°i ƒëƒÉng nh·∫≠p
     */
    async checkAuthStatus() {
        try {
            const isAuthenticated = await this.storageManager.isAuthenticated();
            const hasValidLicense = await this.storageManager.isLicenseActive();
            
            if (!isAuthenticated) {
                return {
                    authenticated: false,
                    hasValidLicense: false,
                    needLogin: true
                };
            }
            
            // Ki·ªÉm tra token c√≥ c√≤n valid kh√¥ng
            const token = await this.storageManager.getCurrentToken();
            const isTokenValid = await this.authAPI.validateToken(token);
            
            if (!isTokenValid) {
                // Token h·∫øt h·∫°n, logout
                await this.logout();
                return {
                    authenticated: false,
                    hasValidLicense: false,
                    needLogin: true,
                    reason: 'token_expired'
                };
            }
            
            return {
                authenticated: true,
                hasValidLicense,
                user: await this.storageManager.getCurrentUser(),
                license: await this.storageManager.getLicenseInfo()
            };
        } catch (err) {
            error('‚ùå Error checking auth status:', err);
            return {
                authenticated: false,
                hasValidLicense: false,
                needLogin: true,
                error: err.message
            };
        }
    }

    /**
     * C·∫≠p nh·∫≠t license t·ª´ API
     */
    async updateLicenseFromAPI(token = null) {
        try {
            if (this.isCheckingLicense) {
                log('üìã License check already in progress, skipping...');
                return;
            }

            this.isCheckingLicense = true;
            
            if (!token) {
                token = await this.storageManager.getCurrentToken();
            }
            
            if (!token) {
                log('‚ö†Ô∏è No token available for license check');
                this.isCheckingLicense = false;
                return;
            }

            log('üìã Updating license from API...');
            
            // L·∫•y license hi·ªán t·∫°i ƒë·ªÉ so s√°nh
            const oldLicense = await this.storageManager.getLicenseInfo();
            const oldLimits = await this.storageManager.getLicenseLimits();
            
            const result = await this.authAPI.getUserInfo(token);
            
            if (result.success) {
                let hasChanges = false;
                
                // C·∫≠p nh·∫≠t license
                if (result.data.user && result.data.user.license) {
                    // Parse license t·ª´ data.user.license thay v√¨ data.licenses
                    const userLicense = result.data.user.license;
                    await this.storageManager.saveLicenseData(userLicense);
                    log('‚úÖ License updated successfully from user data');
                    
                    // Ki·ªÉm tra c√≥ thay ƒë·ªïi kh√¥ng
                    const newLicense = await this.storageManager.getLicenseInfo();
                    const newLimits = await this.storageManager.getLicenseLimits();
                    
                    hasChanges = this.hasLicenseChanged(oldLicense, newLicense, oldLimits, newLimits);
                    
                    if (hasChanges) {
                        log('üîî License has changed, notifying frontend...');
                        await this.notifyLicenseChange('updated', {
                            license: newLicense,
                            limits: newLimits
                        });
                    }
                } else {
                    log('‚ö†Ô∏è No license found in user data');
                    await this.storageManager.clearLicenseData();
                    
                    // License b·ªã x√≥a - lu√¥n notify
                    hasChanges = true;
                    log('üîî License cleared, notifying frontend...');
                    await this.notifyLicenseChange('cleared', {
                        license: null,
                        limits: {
                            accounts: 0,
                            rooms: 0,
                            hasValidLicense: false
                        }
                    });
                }
                
                // C·∫≠p nh·∫≠t th·ªùi gian check
                await this.storageManager.updateLicenseLastChecked();
                
                return { success: true, hasChanges };
                
            } else if (result.needReauth) {
                log('‚ö†Ô∏è Token expired, need re-authentication');
                await this.logout();
                return { success: false, needReauth: true };
            } else {
                error('‚ùå Failed to update license:', result.error);
                return { success: false, error: result.error };
            }
        } catch (err) {
            error('‚ùå Error updating license from API:', err);
            return { success: false, error: err.message };
        } finally {
            this.isCheckingLicense = false;
        }
    }

    /**
     * Ki·ªÉm tra license c√≥ thay ƒë·ªïi kh√¥ng
     */
    hasLicenseChanged(oldLicense, newLicense, oldLimits, newLimits) {
        // N·∫øu m·ªôt trong hai null v√† m·ªôt kh√¥ng null
        if (!oldLicense && newLicense) return true;
        if (oldLicense && !newLicense) return true;
        if (!oldLicense && !newLicense) return false;
        
        // So s√°nh c√°c tr∆∞·ªùng quan tr·ªçng
        const fieldsToCompare = ['status', 'type', 'expiresAt'];
        for (const field of fieldsToCompare) {
            if (oldLicense[field] !== newLicense[field]) {
                return true;
            }
        }
        
        // So s√°nh limits
        if (oldLimits.accounts !== newLimits.accounts) return true;
        if (oldLimits.rooms !== newLimits.rooms) return true;
        if (oldLimits.hasValidLicense !== newLimits.hasValidLicense) return true;
        
        return false;
    }

    /**
     * Notify frontend v·ªÅ license changes
     */
    async notifyLicenseChange(changeType, data) {
        try {
            // Serialize data ƒë·ªÉ tr√°nh IPC errors
            const serializedData = JSON.parse(JSON.stringify({
                type: changeType,
                data: data,
                timestamp: new Date().toISOString()
            }));
            
            log(`üîî Sending license change: ${JSON.stringify(serializedData)}`);
            
            // Broadcast tr·ª±c ti·∫øp to all renderer processes
            const { BrowserWindow } = require('electron');
            const windows = BrowserWindow.getAllWindows();
            
            windows.forEach(window => {
                if (!window.isDestroyed()) {
                    try {
                        window.webContents.send('license-changed', serializedData);
                        log(`‚úÖ Sent to window: ${window.id}`);
                    } catch (err) {
                        error(`‚ùå Failed to send to window ${window.id}:`, err);
                    }
                }
            });
            
            log(`üîî License change notification sent: ${changeType}`);
        } catch (err) {
            error('‚ùå Error notifying license change:', err);
        }
    }

    /**
     * B·∫Øt ƒë·∫ßu ki·ªÉm tra license ƒë·ªãnh k·ª≥
     */
    startLicenseCheck() {
        if (this.checkIntervalId) {
            clearInterval(this.checkIntervalId);
        }
        
        // Check m·ªói 2 ph√∫t
        const checkInterval = 2 * 60 * 1000;
        
        this.checkIntervalId = setInterval(() => {
            this.updateLicenseFromAPI();
        }, checkInterval);
        
        log('‚úÖ License check scheduled every 2 minutes');
    }

    /**
     * D·ª´ng ki·ªÉm tra license ƒë·ªãnh k·ª≥
     */
    stopLicenseCheck() {
        if (this.checkIntervalId) {
            clearInterval(this.checkIntervalId);
            this.checkIntervalId = null;
            log('‚èπÔ∏è License check stopped');
        }
    }

    /**
     * Ki·ªÉm tra gi·ªõi h·∫°n account tr∆∞·ªõc khi import
     */
    async checkAccountImportLimit(newAccountCount) {
        try {
            const currentAccounts = await this.storageManager.getAllAccounts();
            const totalAfterImport = currentAccounts.length + newAccountCount;
            
            const result = await this.storageManager.checkAccountLimit(totalAfterImport);
            
            if (!result.allowed) {
                const limits = await this.storageManager.getLicenseLimits();
                return {
                    allowed: false,
                    reason: result.reason,
                    current: currentAccounts.length,
                    newCount: newAccountCount,
                    totalAfter: totalAfterImport,
                    limit: limits.accounts,
                    message: this.getLimitMessage(result.reason, {
                        current: currentAccounts.length,
                        limit: limits.accounts,
                        requested: newAccountCount
                    })
                };
            }
            
            return { allowed: true };
        } catch (err) {
            error('‚ùå Error checking account import limit:', err);
            return { allowed: false, reason: 'error', error: err.message };
        }
    }

    /**
     * Ki·ªÉm tra gi·ªõi h·∫°n room tr∆∞·ªõc khi start
     */
    async checkRoomStartLimit(newRoomCount = 1) {
        try {
            // ƒê·∫øm s·ªë room ƒëang active
            const rooms = await this.storageManager.getAllRooms();
            const activeRooms = rooms.filter(room => room.status === 'running' || room.isLive).length;
            const totalAfterStart = activeRooms + newRoomCount;
            
            const result = await this.storageManager.checkRoomLimit(totalAfterStart);
            
            if (!result.allowed) {
                const limits = await this.storageManager.getLicenseLimits();
                return {
                    allowed: false,
                    reason: result.reason,
                    current: activeRooms,
                    newCount: newRoomCount,
                    totalAfter: totalAfterStart,
                    limit: limits.rooms,
                    message: this.getLimitMessage(result.reason, {
                        current: activeRooms,
                        limit: limits.rooms,
                        requested: newRoomCount
                    }, 'rooms')
                };
            }
            
            return { allowed: true };
        } catch (err) {
            error('‚ùå Error checking room start limit:', err);
            return { allowed: false, reason: 'error', error: err.message };
        }
    }

    /**
     * T·∫°o message cho limit error
     */
    getLimitMessage(reason, data, type = 'accounts') {
        switch (reason) {
            case 'no_valid_license':
                return 'Kh√¥ng c√≥ license h·ª£p l·ªá. Vui l√≤ng ki·ªÉm tra l·∫°i license c·ªßa b·∫°n.';
            case 'account_limit_exceeded':
                return `V∆∞·ª£t qu√° gi·ªõi h·∫°n t√†i kho·∫£n. Hi·ªán t·∫°i: ${data.current}, Y√™u c·∫ßu th√™m: ${data.requested}, Gi·ªõi h·∫°n: ${data.limit}`;
            case 'room_limit_exceeded':
                return `V∆∞·ª£t qu√° gi·ªõi h·∫°n ph√≤ng live. Hi·ªán t·∫°i: ${data.current}, Y√™u c·∫ßu th√™m: ${data.requested}, Gi·ªõi h·∫°n: ${data.limit}`;
            default:
                return 'ƒê√£ x·∫£y ra l·ªói khi ki·ªÉm tra gi·ªõi h·∫°n license.';
        }
    }

    /**
     * L·∫•y th√¥ng tin t·ªïng quan auth v√† license
     */
    async getAuthSummary() {
        try {
            const user = await this.storageManager.getCurrentUser();
            const license = await this.storageManager.getLicenseInfo();
            const limits = await this.storageManager.getLicenseLimits();
            
            // ƒê·∫øm usage hi·ªán t·∫°i
            const accounts = await this.storageManager.getAllAccounts();
            const rooms = await this.storageManager.getAllRooms();
            const activeRooms = rooms.filter(room => room.status === 'running' || room.isLive);
            
            return {
                user,
                license,
                limits,
                usage: {
                    accounts: accounts.length,
                    activeRooms: activeRooms.length
                },
                canImportAccounts: limits.hasValidLicense && accounts.length < limits.accounts,
                canStartRooms: limits.hasValidLicense && activeRooms.length < limits.rooms
            };
        } catch (err) {
            error('‚ùå Error getting auth summary:', err);
            return null;
        }
    }

    /**
     * Test connection t·ªõi auth server
     */
    async testConnection() {
        return this.authAPI.testConnection();
    }

    /**
     * C·∫≠p nh·∫≠t auth API URL
     */
    setAuthAPIURL(url) {
        this.authAPI.setBaseURL(url);
    }

    /**
     * Cleanup khi app ƒë√≥ng
     */
    cleanup() {
        this.stopLicenseCheck();
    }
}

module.exports = AuthManager; 